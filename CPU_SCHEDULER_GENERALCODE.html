<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Process Scheduler Simulator</title>
    <style>
        :root {
            --nvidia-green: #76b900;
            --nvidia-dark: #1a1a1a;
            --nvidia-gray: #333333;
            --nvidia-light-gray: #666666;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--nvidia-dark);
            color: white;
            padding: 1rem;
            min-height: 100vh;
        }

        header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
        }

        h2 {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: var(--nvidia-green);
        }

        h3 {
            font-size: 1.125rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .grid-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        @media (min-width: 1024px) {
            .grid-container {
                grid-template-columns: minmax(300px, 1fr) minmax(600px, 2fr);
                grid-template-rows: auto;
            }
        }

        .nvidia-card {
            background-color: var(--nvidia-gray);
            border: 1px solid var(--nvidia-light-gray);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .nvidia-btn {
            background-color: var(--nvidia-green);
            color: white;
            font-weight: bold;
            padding: 0.5rem;
            border-radius: 0.25rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 1rem;
        }

        .nvidia-btn:hover {
            background-color: #8dd419;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(118, 185, 0, 0.3);
        }

        .nvidia-btn:active {
            transform: translateY(0);
        }

        .nvidia-input {
            background-color: var(--nvidia-dark);
            border: 1px solid var(--nvidia-light-gray);
            color: white;
            padding: 0.5rem;
            border-radius: 0.25rem;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .nvidia-input:focus {
            border-color: var(--nvidia-green);
            outline: none;
            box-shadow: 0 0 0 2px rgba(118, 185, 0, 0.2);
        }

        .nvidia-select {
            background-color: var(--nvidia-dark);
            border: 1px solid var(--nvidia-light-gray);
            color: white;
            padding: 0.5rem;
            border-radius: 0.25rem;
            width: 100%;
            margin-bottom: 1rem;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;utf8,<svg fill='white' height='24' viewBox='0 0 24 24' width='24' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/><path d='M0 0h24v24H0z' fill='none'/></svg>");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
        }

        .nvidia-select:focus {
            border-color: var(--nvidia-green);
            outline: none;
            box-shadow: 0 0 0 2px rgba(118, 185, 0, 0.2);
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
        }

        .flex {
            display: flex;
        }

        .flex-col {
            flex-direction: column;
        }

        .space-x-2 > * + * {
            margin-left: 0.5rem;
        }

        .mb-4 {
            margin-bottom: 1rem;
        }

        .mb-2 {
            margin-bottom: 0.5rem;
        }

        .mt-1 {
            margin-top: 0.25rem;
        }

        .mt-2 {
            margin-top: 0.5rem;
        }

        .mt-6 {
            margin-top: 1.5rem;
        }

        .w-full {
            width: 100%;
        }

        .text-xs {
            font-size: 0.75rem;
        }

        .text-sm {
            font-size: 0.875rem;
        }

        .text-center {
            text-align: center;
        }

        .text-gray-300 {
            color: #d1d5db;
        }

        .text-gray-400 {
            color: #9ca3af;
        }

        .process-table {
            width: 100%;
            border-collapse: collapse;
        }

        .process-table th {
            background-color: var(--nvidia-green);
            color: white;
            padding: 0.5rem;
            text-align: left;
        }

        .process-table tr:nth-child(even) {
            background-color: var(--nvidia-light-gray);
        }

        .process-table tr:nth-child(odd) {
            background-color: var(--nvidia-gray);
        }

        .process-table td {
            padding: 0.5rem;
        }

        .delete-btn {
            background-color: #dc2626;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            border: none;
            cursor: pointer;
            font-size: 0.875rem;
        }

        .delete-btn:hover {
            background-color: #b91c1c;
        }

        .editable-cell {
            padding: 2px;
            min-width: 40px;
        }

        .editable-cell:focus {
            background-color: var(--nvidia-dark);
            outline: 2px solid var(--nvidia-green);
        }

        .gantt-container {
            position: relative;
            width: 100%;
            overflow-x: auto;
            margin-top: 20px;
            padding: 5px 0;
            background-color: var(--nvidia-dark);
            border-radius: 4px;
            max-width: 100%;
        }

        .gantt-chart {
            height: 60px; /* Reduced height */
            min-width: 100%;
            white-space: nowrap;
            position: relative;
            padding-top: 10px;
        }

        .gantt-block {
            display: inline-block;
            height: 40px; /* Reduced height for blocks */
            text-align: center;
            color: white;
            font-weight: bold;
            line-height: 20px; /* Reduced line height */
            border-radius: 4px;
            margin: 0 3px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .time-marker {
            position: absolute;
            bottom: -20px;
            transform: translateX(-50%);
            font-size: 12px;
            color: #ddd;
            font-weight: bold;
        }

        .time-marker-line {
            position: absolute;
            height: 60px; /* Match the gantt chart height */
            width: 1px;
            background-color: rgba(255, 255, 255, 0.2);
            bottom: 20px;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .running {
            animation: pulse 1s infinite;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: var(--nvidia-dark);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--nvidia-green);
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
        }

        .results-table th {
            background-color: var(--nvidia-green);
            color: white;
            padding: 8px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .results-table td {
            padding: 6px;
            text-align: center;
        }

        .results-table tr:nth-child(even) {
            background-color: var(--nvidia-light-gray);
        }

        .results-table tr:nth-child(odd) {
            background-color: var(--nvidia-gray);
        }

        .results-container {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            border: 1px solid var(--nvidia-light-gray);
            border-radius: 4px;
        }

        .algorithm-settings {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background-color: var(--nvidia-gray);
            border-radius: 4px;
            border: 1px solid var(--nvidia-light-gray);
        }

        .algorithm-settings.active {
            display: block;
        }

        .queue-settings {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .queue-setting {
            display: flex;
            align-items: center;
        }

        .queue-setting label {
            width: 80px;
            font-size: 0.9rem;
            margin-right: 8px;
        }

        .queue-setting input {
            flex: 1;
        }

        .queue-note {
            font-size: 0.8rem;
            color: #aaa;
            margin-top: 8px;
            font-style: italic;
        }

        .grid-2-cols {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }

        @media (min-width: 768px) {
            .grid-2-cols {
                grid-template-columns: 1fr 1fr;
            }
        }

        .overflow-x-auto {
            overflow-x: auto;
        }

        .justify-between {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .refresh-icon {
            width: 20px;
            height: 20px;
        }
        
        /* New styles for improved Gantt chart */
        .gantt-time-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        .gantt-time-label {
            position: absolute;
            bottom: -25px;
            font-size: 12px;
            color: #ddd;
            text-align: center;
            font-weight: bold;
        }
        
        /* Improved gantt block content layout */
        .gantt-block-content {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            height: 100%;
            padding: 2px;
            gap: 4px;
        }
        
        .gantt-block-pid {
            font-size: 14px;
            font-weight: bold;
        }
        
        .gantt-block-time {
            font-size: 11px;
            opacity: 0.9;
        }
        
        .gantt-block-queue {
            font-size: 10px;
            opacity: 0.8;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 0 3px;
            border-radius: 2px;
        }
        
        .gantt-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 30px;
            padding: 5px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 10px;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* Algorithm selector styles */
        .algorithm-selector {
            margin-bottom: 1.5rem;
        }
        
        /* Fixed panel sizes */
        .left-panel {
            height: auto;
            min-height: 600px;
        }
        
        .right-panel {
            height: auto;
            min-height: 600px;
        }
        
        /* Ensure gantt chart container doesn't affect layout */
        .gantt-wrapper {
            width: 100%;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <header>
        <h1>Process Scheduler Simulator</h1>
    </header>

    <div class="grid-container">
        <!-- Process Input Section -->
        <div class="nvidia-card left-panel">
            <h2>Process Input</h2>
            
            <div class="mb-4">
                <label>Process ID</label>
                <div class="flex space-x-2">
                    <input type="text" id="processId" placeholder="Auto-assigned" class="nvidia-input" readonly>
                    <button id="refreshPid" class="nvidia-btn" style="width: auto; padding: 0.5rem;" title="Get next available PID">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="refresh-icon">
                            <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
                <div class="text-xs mt-1 text-gray-300">Process IDs are automatically assigned sequentially</div>
            </div>
            
            <div class="mb-4">
                <label>Arrival Time</label>
                <input type="number" id="arrivalTime" min="0" value="0" class="nvidia-input">
            </div>
            
            <div class="mb-4">
                <label>Burst Time</label>
                <input type="number" id="burstTime" min="1" value="5" class="nvidia-input">
            </div>
            
            <button id="addProcess" class="nvidia-btn">Add Process</button>
            
            <!-- Algorithm selection and settings -->
            <div class="mb-4">
                <h3>Algorithm Selection</h3>
                <select id="algorithmSelect" class="nvidia-select">
                    <option value="fcfs">First-In First-Out (FIFO/FCFS)</option>
                    <option value="sjf">Shortest Job First (SJF - Non-Preemptive)</option>
                    <option value="srtf">Shortest Remaining Time First (SRTF - Preemptive)</option>
                    <option value="rr">Round Robin (RR)</option>
                    <option value="mlfq">Multilevel Feedback Queue (MLFQ)</option>
                </select>
                
                <!-- Round Robin settings -->
                <div id="rr-settings" class="algorithm-settings">
                    <label>Time Quantum</label>
                    <input type="number" id="timeQuantum" min="1" value="2" class="nvidia-input">
                </div>
                
                <!-- MLFQ settings -->
                <div id="mlfq-settings" class="algorithm-settings">
                    <label>Queue Time Quantums</label>
                    <div class="queue-settings">
                        <div class="queue-setting">
                            <label>Queue 0:</label>
                            <input type="number" id="mlfq-q0" min="0" value="2" class="nvidia-input">
                        </div>
                        <div class="queue-setting">
                            <label>Queue 1:</label>
                            <input type="number" id="mlfq-q1" min="0" value="4" class="nvidia-input">
                        </div>
                        <div class="queue-setting">
                            <label>Queue 2:</label>
                            <input type="number" id="mlfq-q2" min="0" value="8" class="nvidia-input">
                        </div>
                        <div class="queue-setting">
                            <label>Queue 3:</label>
                            <input type="number" id="mlfq-q3" min="0" value="16" class="nvidia-input">
                        </div>
                    </div>
                    <p class="queue-note">Set a queue's time quantum to 0 to disable that queue level. At least one queue must have a non-zero time quantum.</p>
                </div>
            </div>
            
            <div class="mb-4">
                <label>Generate Random Processes</label>
                <div class="flex space-x-2">
                    <input type="number" id="randomCount" min="1" max="20" value="5" class="nvidia-input" style="width: 50%;" placeholder="Count">
                    <button id="generateRandom" class="nvidia-btn" style="width: 50%;">Generate</button>
                </div>
                <div class="text-xs mt-1 text-gray-300">Generates processes with random arrival and burst times</div>
            </div>
            
            <button id="clearProcesses" class="nvidia-btn" style="background-color: #dc2626;">Clear All Processes</button>
        </div>
        
        <!-- Scheduling Algorithms Section -->
        <div class="nvidia-card right-panel">
            <div class="mb-4">
                <div class="justify-between mb-2">
                    <h3>Process Table</h3>
                    <div class="tooltip">
                        <span class="text-xs" style="background-color: var(--nvidia-green); padding: 0.25rem 0.5rem; border-radius: 0.25rem;">?</span>
                        <span class="tooltiptext">Click on any cell to edit its value</span>
                    </div>
                </div>
                <div class="overflow-x-auto">
                    <table class="process-table">
                        <thead>
                            <tr>
                                <th>Process ID</th>
                                <th>Arrival Time</th>
                                <th>Burst Time</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="processTableBody">
                            <!-- Process rows will be added here -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <button id="runSimulation" class="nvidia-btn">Run Simulation</button>
            
            <div class="mb-4">
                <h3 class="mb-2">Gantt Chart</h3>
                <div class="gantt-wrapper">
                    <div class="gantt-container">
                        <div id="ganttChart" class="gantt-chart"></div>
                    </div>
                </div>
                <div class="text-xs mt-1 text-gray-400 text-center">Time units â†’</div>
                <div id="ganttLegend" class="gantt-legend">
                    <!-- Legend items will be added here -->
                </div>
            </div>
            
            <div class="grid-2-cols">
                <div class="nvidia-card">
                    <h3 class="mb-2">Results</h3>
                    <div class="results-container">
                        <table class="results-table">
                            <thead>
                                <tr>
                                    <th>PID</th>
                                    <th>AT</th>
                                    <th>BT</th>
                                    <th>WT</th>
                                    <th>TT</th>
                                    <th>CT</th>
                                </tr>
                            </thead>
                            <tbody id="resultsTableBody">
                                <!-- Results will be added here -->
                            </tbody>
                        </table>
                    </div>
                    <div id="averageMetrics" class="mt-2">
                        <p>Average Waiting Time: <span id="avgWaitingTime">0.00</span> ms</p>
                        <p>Average Turnaround Time: <span id="avgTurnaroundTime">0.00</span> ms</p>
                        <p>Average Response Time: <span id="avgResponseTime">0.00</span> ms</p>
                    </div>
                </div>
                
                <div class="nvidia-card">
                    <h3 class="mb-2">Current Status</h3>
                    <div id="currentStatus">
                        <p>Current Time: <span id="currentTime">0</span> ms</p>
                        <p>Running Process: <span id="runningProcess">None</span></p>
                        <p>Queue: <span id="readyQueue">Empty</span></p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="nvidia-card mt-6">
        <h2>Algorithm Description</h2>
        <div id="algorithmDescription" class="text-sm">
            <h3>First-In First-Out (FIFO / FCFS)</h3>
            <p>Processes are executed in the order they arrive in the ready queue. Simple but can lead to the "convoy effect" where short processes wait for long ones.</p>
        </div>
    </div>

    <script>
        // Process class
        class Process {
            constructor(id, arrivalTime, burstTime) {
                this.id = id;
                this.arrivalTime = parseInt(arrivalTime);
                this.burstTime = parseInt(burstTime);
                this.remainingTime = parseInt(burstTime);
                this.startTime = -1;
                this.finishTime = -1;
                this.waitingTime = 0;
                this.responseTime = -1;
                this.turnaroundTime = 0;
                this.color = this.generateColor();
                this.currentQueue = 0; // For MLFQ tracking
            }
            
            generateColor() {
                // Generate a random color but avoid colors too close to NVIDIA green
                const hue = Math.floor(Math.random() * 360);
                const saturation = 70 + Math.random() * 30;
                const lightness = 40 + Math.random() * 20;
                return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            }
            
            // Create a deep copy of this process
            clone() {
                const copy = new Process(this.id, this.arrivalTime, this.burstTime);
                copy.remainingTime = this.remainingTime;
                copy.startTime = this.startTime;
                copy.finishTime = this.finishTime;
                copy.waitingTime = this.waitingTime;
                copy.responseTime = this.responseTime;
                copy.turnaroundTime = this.turnaroundTime;
                copy.color = this.color;
                copy.currentQueue = this.currentQueue;
                return copy;
            }
        }

        // Scheduler class
        class Scheduler {
            constructor() {
                this.processes = [];
                this.timeQuantum = 2;
                this.mlfqQuantums = [2, 4, 8, 16]; // Default time quantums for MLFQ queues
                this.currentAlgorithm = 'fcfs';
                this.ganttChart = [];
                this.currentTime = 0;
                this.isRunning = false;
                this.nextProcessId = 1; // Track the next available process ID
                this.debugMode = false; // Set to true to enable console logging
                this.completedProcesses = []; // Store completed processes for results
            }
            
            log(message) {
                if (this.debugMode) {
                    console.log(message);
                }
            }
            
            getNextProcessId() {
                // Find the highest process ID number
                let maxId = 0;
                this.processes.forEach(process => {
                    const idNum = parseInt(process.id.replace('P', ''));
                    if (!isNaN(idNum) && idNum > maxId) {
                        maxId = idNum;
                    }
                });
                
                // Return the next sequential ID
                return `P${maxId + 1}`;
            }
            
            updateNextProcessIdInput() {
                document.getElementById('processId').value = this.getNextProcessId();
            }
            
            addProcess(process) {
                this.processes.push(process);
                this.updateProcessTable();
                this.updateNextProcessIdInput();
            }
            
            removeProcess(id) {
                this.processes = this.processes.filter(p => p.id !== id);
                this.updateProcessTable();
                this.updateNextProcessIdInput();
            }
            
            clearProcesses() {
                this.processes = [];
                this.nextProcessId = 1;
                this.updateProcessTable();
                this.updateNextProcessIdInput();
                this.resetSimulation();
            }
            
            updateProcess(id, field, value) {
                const process = this.processes.find(p => p.id === id);
                if (process) {
                    if (field === 'id') {
                        // Process IDs are now auto-assigned and sequential
                        // We don't allow changing them
                        return false;
                    } else if (field === 'arrivalTime') {
                        process.arrivalTime = parseInt(value);
                    } else if (field === 'burstTime') {
                        process.burstTime = parseInt(value);
                        process.remainingTime = parseInt(value);
                    }
                    return true;
                }
                return false;
            }
            
            updateProcessTable() {
                const tableBody = document.getElementById('processTableBody');
                tableBody.innerHTML = '';
                
                // Sort processes by ID for display
                const sortedProcesses = [...this.processes].sort((a, b) => {
                    const idA = parseInt(a.id.replace('P', ''));
                    const idB = parseInt(b.id.replace('P', ''));
                    return idA - idB;
                });
                
                sortedProcesses.forEach(process => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>
                            <div class="editable-cell" contenteditable="false" data-id="${process.id}" data-field="id">${process.id}</div>
                        </td>
                        <td>
                            <div class="editable-cell" contenteditable="true" data-id="${process.id}" data-field="arrivalTime">${process.arrivalTime}</div>
                        </td>
                        <td>
                            <div class="editable-cell" contenteditable="true" data-id="${process.id}" data-field="burstTime">${process.burstTime}</div>
                        </td>
                        <td>
                            <button class="delete-btn" data-id="${process.id}">Delete</button>
                        </td>
                    `;
                    tableBody.appendChild(row);
                });
                
                // Add event listeners to delete buttons
                document.querySelectorAll('.delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.target.getAttribute('data-id');
                        this.removeProcess(id);
                    });
                });
                
                // Add event listeners to editable cells
                document.querySelectorAll('.editable-cell').forEach(cell => {
                    if (cell.getAttribute('data-field') === 'id') {
                        // Process IDs are not editable
                        return;
                    }
                    
                    cell.addEventListener('blur', (e) => {
                        const id = e.target.getAttribute('data-id');
                        const field = e.target.getAttribute('data-field');
                        const value = e.target.textContent.trim();
                        
                        if (value === '') {
                            alert('Value cannot be empty!');
                            e.target.textContent = e.target.getAttribute('data-original-value') || '';
                            return;
                        }
                        
                        if ((field === 'arrivalTime' || field === 'burstTime') && 
                            (isNaN(parseInt(value)) || parseInt(value) < 0)) {
                            alert('Please enter a valid non-negative number!');
                            e.target.textContent = e.target.getAttribute('data-original-value') || '';
                            return;
                        }
                        
                        if (field === 'burstTime' && parseInt(value) === 0) {
                            alert('Burst time must be greater than 0!');
                            e.target.textContent = e.target.getAttribute('data-original-value') || '';
                            return;
                        }
                        
                        const success = this.updateProcess(id, field, value);
                        if (!success) {
                            e.target.textContent = e.target.getAttribute('data-original-value') || '';
                        }
                    });
                    
                    cell.addEventListener('focus', (e) => {
                        e.target.setAttribute('data-original-value', e.target.textContent);
                    });
                    
                    cell.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            e.target.blur();
                        }
                    });
                });
            }
            
            generateRandomProcesses(count) {
                for (let i = 0; i < count; i++) {
                    // Get the next sequential process ID
                    const id = this.getNextProcessId();
                    
                    // Generate random parameters
                    const arrivalTime = Math.floor(Math.random() * 10);
                    const burstTime = Math.floor(Math.random() * 10) + 1; // Ensure burst time is at least 1
                    
                    this.addProcess(new Process(id, arrivalTime, burstTime));
                }
            }
            
            setAlgorithm(algorithm) {
                this.currentAlgorithm = algorithm;
                this.updateAlgorithmDescription();
                this.showAlgorithmSettings();
            }
            
            showAlgorithmSettings() {
                // Hide all algorithm settings
                document.querySelectorAll('.algorithm-settings').forEach(setting => {
                    setting.classList.remove('active');
                });
                
                // Show settings for the current algorithm
                if (this.currentAlgorithm === 'rr') {
                    document.getElementById('rr-settings').classList.add('active');
                } else if (this.currentAlgorithm === 'mlfq') {
                    document.getElementById('mlfq-settings').classList.add('active');
                }
            }
            
            updateAlgorithmDescription() {
                const descriptionDiv = document.getElementById('algorithmDescription');
                
                switch(this.currentAlgorithm) {
                    case 'fcfs':
                        descriptionDiv.innerHTML = `
                            <h3>First-In First-Out (FIFO / FCFS)</h3>
                            <p>Processes are executed in the order they arrive in the ready queue. Simple but can lead to the "convoy effect" where short processes wait for long ones.</p>
                        `;
                        break;
                    case 'sjf':
                        descriptionDiv.innerHTML = `
                            <h3>Shortest Job First (SJF) - Non-Preemptive</h3>
                            <p>Selects the process with the smallest burst time from the ready queue. Once a process starts executing, it runs to completion.</p>
                        `;
                        break;
                    case 'srtf':
                        descriptionDiv.innerHTML = `
                            <h3>Shortest Remaining Time First (SRTF) - Preemptive</h3>
                            <p>Preemptive version of SJF. If a new process arrives with a burst time less than the remaining time of the current process, the current process is preempted.</p>
                        `;
                        break;
                    case 'rr':
                        descriptionDiv.innerHTML = `
                            <h3>Round Robin (RR)</h3>
                            <p>Each process is assigned a fixed time slice (time quantum). After this time has elapsed, the process is preempted and added to the end of the ready queue.</p>
                        `;
                        break;
                    case 'mlfq':
                        // Filter out queues with zero time quantum
                        const activeQueues = this.mlfqQuantums
                            .map((q, i) => ({ quantum: q, index: i }))
                            .filter(q => q.quantum > 0);
                        
                        let queueDescription = '';
                        if (activeQueues.length > 0) {
                            queueDescription = '<ul style="list-style-type: disc; padding-left: 1.25rem; margin-top: 0.25rem;">';
                            activeQueues.forEach(q => {
                                queueDescription += `<li>Queue ${q.index}: ${q.index === 0 ? 'Highest' : q.index === activeQueues.length - 1 ? 'Lowest' : 'Medium'} priority, Time Quantum = ${q.quantum}</li>`;
                            });
                            queueDescription += '</ul>';
                        } else {
                            queueDescription = '<p style="margin-top: 0.5rem; color: #ef4444;">Warning: No active queues defined! Please set at least one queue with a non-zero time quantum.</p>';
                        }
                        
                        descriptionDiv.innerHTML = `
                            <h3>Multilevel Feedback Queue (MLFQ)</h3>
                            <p>Uses multiple levels of queues with different priorities. Processes move between queues based on their behavior and CPU bursts. Combines benefits of RR and priority scheduling.</p>
                            <p style="margin-top: 0.5rem;">In this implementation:</p>
                            ${queueDescription}
                            <p style="margin-top: 0.5rem;">Processes start in the highest priority queue and move to lower priority queues if they use their full time quantum.</p>
                        `;
                        break;
                }
            }
            
            setTimeQuantum(quantum) {
                this.timeQuantum = parseInt(quantum);
            }
            
            setMLFQQuantums(q0, q1, q2, q3) {
                this.mlfqQuantums = [
                    parseInt(q0),
                    parseInt(q1),
                    parseInt(q2),
                    parseInt(q3)
                ];
                this.updateAlgorithmDescription();
            }
            
            resetSimulation() {
                this.ganttChart = [];
                this.currentTime = 0;
                this.isRunning = false;
                this.completedProcesses = [];
                
                // Reset process states
                this.processes.forEach(process => {
                    process.remainingTime = process.burstTime;
                    process.startTime = -1;
                    process.finishTime = -1;
                    process.waitingTime = 0;
                    process.responseTime = -1;
                    process.turnaroundTime = 0;
                    process.currentQueue = 0;
                });
                
                // Clear UI
                document.getElementById('ganttChart').innerHTML = '';
                document.getElementById('ganttLegend').innerHTML = '';
                document.getElementById('resultsTableBody').innerHTML = '';
                document.getElementById('avgWaitingTime').textContent = '0.00';
                document.getElementById('avgTurnaroundTime').textContent = '0.00';
                document.getElementById('avgResponseTime').textContent = '0.00';
                document.getElementById('currentTime').textContent = '0';
                document.getElementById('runningProcess').textContent = 'None';
                document.getElementById('readyQueue').textContent = 'Empty';
            }
            
            runSimulation() {
                if (this.processes.length === 0) {
                    alert('Please add at least one process first!');
                    return;
                }
                
                // For MLFQ, validate that at least one queue has a non-zero time quantum
                if (this.currentAlgorithm === 'mlfq') {
                    const hasActiveQueue = this.mlfqQuantums.some(q => q > 0);
                    if (!hasActiveQueue) {
                        alert('MLFQ requires at least one queue with a non-zero time quantum!');
                        return;
                    }
                }
                
                this.resetSimulation();
                this.isRunning = true;
                
                // Create deep copies of processes to avoid modifying the originals
                const processesCopy = this.processes.map(p => p.clone());
                
                // Sort processes by arrival time
                const sortedProcesses = [...processesCopy].sort((a, b) => a.arrivalTime - b.arrivalTime);
                
                switch(this.currentAlgorithm) {
                    case 'fcfs':
                        this.runFCFS(sortedProcesses);
                        break;
                    case 'sjf':
                        this.runSJF(sortedProcesses);
                        break;
                    case 'srtf':
                        this.runSRTF(sortedProcesses);
                        break;
                    case 'rr':
                        this.runRR(sortedProcesses);
                        break;
                    case 'mlfq':
                        this.runMLFQ(sortedProcesses);
                        break;
                }
                
                this.updateGanttChart();
                this.calculateMetrics(this.completedProcesses);
                this.updateResultsTable(this.completedProcesses);
            }
            
            runFCFS(processes) {
                let currentTime = 0;
                const readyQueue = [];
                this.completedProcesses = [];
                
                // Handle idle time at the beginning if no process arrives at time 0
                if (processes.length > 0 && processes[0].arrivalTime > 0) {
                    this.ganttChart.push({
                        processId: "Idle",
                        startTime: 0,
                        endTime: processes[0].arrivalTime,
                        color: "#555555"
                    });
                    currentTime = processes[0].arrivalTime;
                }
                
                while (processes.length > 0 || readyQueue.length > 0) {
                    // Add processes that have arrived to the ready queue
                    while (processes.length > 0 && processes[0].arrivalTime <= currentTime) {
                        readyQueue.push(processes.shift());
                    }
                    
                    if (readyQueue.length === 0) {
                        // No process in ready queue, advance time to next arrival
                        if (processes.length > 0) {
                            // Add idle time to Gantt chart
                            this.ganttChart.push({
                                processId: "Idle",
                                startTime: currentTime,
                                endTime: processes[0].arrivalTime,
                                color: "#555555"
                            });
                            currentTime = processes[0].arrivalTime;
                        } else {
                            break;
                        }
                        continue;
                    }
                    
                    // Get the first process from the ready queue
                    const currentProcess = readyQueue.shift();
                    
                    // If this is the first time the process runs, set its response time
                    if (currentProcess.responseTime === -1) {
                        currentProcess.responseTime = currentTime - currentProcess.arrivalTime;
                    }
                    
                    // Set start time if not set
                    if (currentProcess.startTime === -1) {
                        currentProcess.startTime = currentTime;
                    }
                    
                    // Add to Gantt chart
                    this.ganttChart.push({
                        processId: currentProcess.id,
                        startTime: currentTime,
                        endTime: currentTime + currentProcess.remainingTime,
                        color: currentProcess.color
                    });
                    
                    // Update current time
                    currentTime += currentProcess.remainingTime;
                    
                    // Process is complete
                    currentProcess.remainingTime = 0;
                    currentProcess.finishTime = currentTime;
                    this.completedProcesses.push(currentProcess);
                }
            }
            
            runSJF(processes) {
                let currentTime = 0;
                const readyQueue = [];
                this.completedProcesses = [];
                
                // Handle idle time at the beginning if no process arrives at time 0
                if (processes.length > 0 && processes[0].arrivalTime > 0) {
                    this.ganttChart.push({
                        processId: "Idle",
                        startTime: 0,
                        endTime: processes[0].arrivalTime,
                        color: "#555555"
                    });
                    currentTime = processes[0].arrivalTime;
                }
                
                while (processes.length > 0 || readyQueue.length > 0) {
                    // Add processes that have arrived to the ready queue
                    while (processes.length > 0 && processes[0].arrivalTime <= currentTime) {
                        readyQueue.push(processes.shift());
                    }
                    
                    if (readyQueue.length === 0) {
                        // No process in ready queue, advance time to next arrival
                        if (processes.length > 0) {
                            // Add idle time to Gantt chart
                            this.ganttChart.push({
                                processId: "Idle",
                                startTime: currentTime,
                                endTime: processes[0].arrivalTime,
                                color: "#555555"
                            });
                            currentTime = processes[0].arrivalTime;
                        } else {
                            break;
                        }
                        continue;
                    }
                    
                    // Sort ready queue by burst time (shortest first)
                    readyQueue.sort((a, b) => a.burstTime - b.burstTime);
                    
                    // Get the process with shortest burst time
                    const currentProcess = readyQueue.shift();
                    
                    // If this is the first time the process runs, set its response time
                    if (currentProcess.responseTime === -1) {
                        currentProcess.responseTime = currentTime - currentProcess.arrivalTime;
                    }
                    
                    // Set start time if not set
                    if (currentProcess.startTime === -1) {
                        currentProcess.startTime = currentTime;
                    }
                    
                    // Add to Gantt chart
                    this.ganttChart.push({
                        processId: currentProcess.id,
                        startTime: currentTime,
                        endTime: currentTime + currentProcess.remainingTime,
                        color: currentProcess.color
                    });
                    
                    // Update current time
                    currentTime += currentProcess.remainingTime;
                    
                    // Process is complete
                    currentProcess.remainingTime = 0;
                    currentProcess.finishTime = currentTime;
                    this.completedProcesses.push(currentProcess);
                }
            }
            
            runSRTF(processes) {
                let currentTime = 0;
                const readyQueue = [];
                this.completedProcesses = [];
                let currentProcess = null;
                
                // Handle idle time at the beginning if no process arrives at time 0
                if (processes.length > 0 && processes[0].arrivalTime > 0) {
                    this.ganttChart.push({
                        processId: "Idle",
                        startTime: 0,
                        endTime: processes[0].arrivalTime,
                        color: "#555555"
                    });
                    currentTime = processes[0].arrivalTime;
                }
                
                while (processes.length > 0 || readyQueue.length > 0 || currentProcess) {
                    // Add processes that have arrived to the ready queue
                    while (processes.length > 0 && processes[0].arrivalTime <= currentTime) {
                        readyQueue.push(processes.shift());
                    }
                    
                    // Check if we need to preempt the current process
                    if (currentProcess && readyQueue.length > 0) {
                        readyQueue.sort((a, b) => a.remainingTime - b.remainingTime);
                        if (readyQueue[0].remainingTime < currentProcess.remainingTime) {
                            readyQueue.push(currentProcess);
                            currentProcess = null;
                        }
                    }
                    
                    // If no current process, get the one with shortest remaining time
                    if (!currentProcess) {
                        if (readyQueue.length === 0) {
                            // No process in ready queue, advance time to next arrival
                            if (processes.length > 0) {
                                // Add idle time to Gantt chart
                                this.ganttChart.push({
                                    processId: "Idle",
                                    startTime: currentTime,
                                    endTime: processes[0].arrivalTime,
                                    color: "#555555"
                                });
                                currentTime = processes[0].arrivalTime;
                            } else {
                                break;
                            }
                            continue;
                        }
                        
                        readyQueue.sort((a, b) => a.remainingTime - b.remainingTime);
                        currentProcess = readyQueue.shift();
                        
                        // If this is the first time the process runs, set its response time
                        if (currentProcess.responseTime === -1) {
                            currentProcess.responseTime = currentTime - currentProcess.arrivalTime;
                        }
                        
                        // Set start time if not set
                        if (currentProcess.startTime === -1) {
                            currentProcess.startTime = currentTime;
                        }
                    }
                    
                    // Determine how long the current process will run
                    let runUntil = currentTime + currentProcess.remainingTime;
                    
                    // Check if a new process will arrive before this one finishes
                    if (processes.length > 0 && processes[0].arrivalTime < runUntil) {
                        runUntil = processes[0].arrivalTime;
                    }
                    
                    // Add to Gantt chart
                    if (runUntil > currentTime) {
                        this.ganttChart.push({
                            processId: currentProcess.id,
                            startTime: currentTime,
                            endTime: runUntil,
                            color: currentProcess.color
                        });
                        
                        // Update remaining time
                        currentProcess.remainingTime -= (runUntil - currentTime);
                        currentTime = runUntil;
                        
                        // Check if process is complete
                        if (currentProcess.remainingTime <= 0) {
                            currentProcess.finishTime = currentTime;
                            this.completedProcesses.push(currentProcess);
                            currentProcess = null;
                        }
                    } else {
                        // Edge case: time didn't advance
                        currentTime++;
                    }
                }
            }
            
            runRR(processes) {
                let currentTime = 0;
                const readyQueue = [];
                this.completedProcesses = [];
                
                // Handle idle time at the beginning if no process arrives at time 0
                if (processes.length > 0 && processes[0].arrivalTime > 0) {
                    this.ganttChart.push({
                        processId: "Idle",
                        startTime: 0,
                        endTime: processes[0].arrivalTime,
                        color: "#555555"
                    });
                    currentTime = processes[0].arrivalTime;
                }
                
                while (processes.length > 0 || readyQueue.length > 0) {
                    // Add processes that have arrived to the ready queue
                    while (processes.length > 0 && processes[0].arrivalTime <= currentTime) {
                        readyQueue.push(processes.shift());
                    }
                    
                    if (readyQueue.length === 0) {
                        // No process in ready queue, advance time to next arrival
                        if (processes.length > 0) {
                            // Add idle time to Gantt chart
                            this.ganttChart.push({
                                processId: "Idle",
                                startTime: currentTime,
                                endTime: processes[0].arrivalTime,
                                color: "#555555"
                            });
                            currentTime = processes[0].arrivalTime;
                        } else {
                            break;
                        }
                        continue;
                    }
                    
                    // Get the next process from the ready queue
                    const currentProcess = readyQueue.shift();
                    
                    // If this is the first time the process runs, set its response time
                    if (currentProcess.responseTime === -1) {
                        currentProcess.responseTime = currentTime - currentProcess.arrivalTime;
                    }
                    
                    // Set start time if not set
                    if (currentProcess.startTime === -1) {
                        currentProcess.startTime = currentTime;
                    }
                    
                    // Determine how long this process will run
                    const timeSlice = Math.min(this.timeQuantum, currentProcess.remainingTime);
                    
                    // Add to Gantt chart
                    this.ganttChart.push({
                        processId: currentProcess.id,
                        startTime: currentTime,
                        endTime: currentTime + timeSlice,
                        color: currentProcess.color
                    });
                    
                    // Update current time and remaining time
                    currentTime += timeSlice;
                    currentProcess.remainingTime -= timeSlice;
                    
                    // Add newly arrived processes to ready queue
                    while (processes.length > 0 && processes[0].arrivalTime <= currentTime) {
                        readyQueue.push(processes.shift());
                    }
                    
                    // Check if process is complete
                    if (currentProcess.remainingTime <= 0) {
                        currentProcess.finishTime = currentTime;
                        this.completedProcesses.push(currentProcess);
                    } else {
                        // Put the process back in the ready queue
                        readyQueue.push(currentProcess);
                    }
                }
            }
            
            runMLFQ(processes) {
                let currentTime = 0;
                
                // Create queues with different time quantums, filtering out disabled queues (quantum = 0)
                const queues = this.mlfqQuantums
                    .map((quantum, index) => ({ 
                        processes: [], 
                        quantum: quantum,
                        level: index 
                    }))
                    .filter(queue => queue.quantum > 0);
                
                this.completedProcesses = [];
                
                // Handle idle time at the beginning if no process arrives at time 0
                if (processes.length > 0 && processes[0].arrivalTime > 0) {
                    this.ganttChart.push({
                        processId: "Idle",
                        startTime: 0,
                        endTime: processes[0].arrivalTime,
                        color: "#555555"
                    });
                    currentTime = processes[0].arrivalTime;
                }
                
                this.log("Starting MLFQ simulation with " + queues.length + " active queues");
                
                while (processes.length > 0 || queues.some(q => q.processes.length > 0)) {
                    // Add processes that have arrived to the highest priority queue
                    while (processes.length > 0 && processes[0].arrivalTime <= currentTime) {
                        const newProcess = processes.shift();
                        newProcess.currentQueue = 0; // Start in highest priority queue
                        queues[0].processes.push(newProcess);
                        this.log(`Time ${currentTime}: Process ${newProcess.id} arrived and added to Queue 0`);
                    }
                    
                    // Find the highest non-empty queue
                    let queueIndex = 0;
                    while (queueIndex < queues.length && queues[queueIndex].processes.length === 0) {
                        queueIndex++;
                    }
                    
                    if (queueIndex === queues.length) {
                        // All queues are empty, advance time to next arrival
                        if (processes.length > 0) {
                            // Add idle time to Gantt chart
                            this.ganttChart.push({
                                processId: "Idle",
                                startTime: currentTime,
                                endTime: processes[0].arrivalTime,
                                color: "#555555"
                            });
                            currentTime = processes[0].arrivalTime;
                            this.log(`Time ${currentTime}: All queues empty, advancing to next arrival time`);
                        } else {
                            this.log(`Time ${currentTime}: All queues empty and no more processes, ending simulation`);
                            break;
                        }
                        continue;
                    }
                    
                    // Get the next process from the selected queue
                    const currentQueue = queues[queueIndex];
                    const currentProcess = currentQueue.processes.shift();
                    
                    this.log(`Time ${currentTime}: Running process ${currentProcess.id} from Queue ${currentQueue.level} (remaining: ${currentProcess.remainingTime}ms)`);
                    
                    // If this is the first time the process runs, set its response time
                    if (currentProcess.responseTime === -1) {
                        currentProcess.responseTime = currentTime - currentProcess.arrivalTime;
                        this.log(`Time ${currentTime}: First response for ${currentProcess.id}, response time: ${currentProcess.responseTime}`);
                    }
                    
                    // Set start time if not set
                    if (currentProcess.startTime === -1) {
                        currentProcess.startTime = currentTime;
                        this.log(`Time ${currentTime}: First start for ${currentProcess.id}`);
                    }
                    
                    // Determine how long this process will run
                    const timeSlice = Math.min(currentQueue.quantum, currentProcess.remainingTime);
                    
                    this.log(`Time ${currentTime}: Process ${currentProcess.id} will run for ${timeSlice}ms (quantum: ${currentQueue.quantum}ms)`);
                    
                    // Add to Gantt chart
                    this.ganttChart.push({
                        processId: currentProcess.id,
                        startTime: currentTime,
                        endTime: currentTime + timeSlice,
                        color: currentProcess.color,
                        queueLevel: currentQueue.level // Track which queue this execution came from
                    });
                    
                    // Update current time and remaining time
                    currentTime += timeSlice;
                    currentProcess.remainingTime -= timeSlice;
                    
                    this.log(`Time ${currentTime}: Process ${currentProcess.id} ran for ${timeSlice}ms, remaining: ${currentProcess.remainingTime}ms`);
                    
                    // Add newly arrived processes to highest priority queue
                    while (processes.length > 0 && processes[0].arrivalTime <= currentTime) {
                        const newProcess = processes.shift();
                        newProcess.currentQueue = 0; // Start in highest priority queue
                        queues[0].processes.push(newProcess);
                        this.log(`Time ${currentTime}: Process ${newProcess.id} arrived and added to Queue 0`);
                    }
                    
                    // Check if process is complete
                    if (currentProcess.remainingTime <= 0) {
                        currentProcess.finishTime = currentTime;
                        this.completedProcesses.push(currentProcess);
                        this.log(`Time ${currentTime}: Process ${currentProcess.id} completed, finish time: ${currentProcess.finishTime}`);
                    } else {
                        // Move the process to a lower priority queue if not already at lowest
                        const currentQueueIndex = queues.findIndex(q => q.level === currentQueue.level);
                        const nextQueueIndex = Math.min(currentQueueIndex + 1, queues.length - 1);
                        currentProcess.currentQueue = queues[nextQueueIndex].level;
                        queues[nextQueueIndex].processes.push(currentProcess);
                        this.log(`Time ${currentTime}: Process ${currentProcess.id} moved to Queue ${queues[nextQueueIndex].level}`);
                    }
                }
                
                // Verify all processes completed
                const totalBurstTime = this.completedProcesses.reduce((sum, p) => sum + p.burstTime, 0);
                const totalExecutedTime = this.ganttChart
                    .filter(block => block.processId !== "Idle")
                    .reduce((sum, block) => sum + (block.endTime - block.startTime), 0);
                
                this.log(`MLFQ Simulation completed. Total burst time: ${totalBurstTime}, Total executed time: ${totalExecutedTime}`);
                if (totalBurstTime !== totalExecutedTime) {
                    console.warn(`Warning: Total burst time (${totalBurstTime}) does not match total executed time (${totalExecutedTime})`);
                }
                
                // Verify each process completed its full burst time
                this.completedProcesses.forEach(process => {
                    const executedTime = this.ganttChart
                        .filter(block => block.processId === process.id)
                        .reduce((sum, block) => sum + (block.endTime - block.startTime), 0);
                    
                    if (executedTime !== process.burstTime) {
                        console.warn(`Warning: Process ${process.id} executed for ${executedTime}ms but has burst time of ${process.burstTime}ms`);
                    }
                });
            }
            
            updateGanttChart() {
                const ganttChartDiv = document.getElementById('ganttChart');
                const legendDiv = document.getElementById('ganttLegend');
                ganttChartDiv.innerHTML = '';
                legendDiv.innerHTML = '';
                
                if (this.ganttChart.length === 0) return;
                
                // Calculate total width and time
                const totalTime = this.ganttChart[this.ganttChart.length - 1].endTime;
                const pixelsPerTimeUnit = 50; // Fixed width per time unit for better visibility
                
                // Set the width of the gantt chart container based on the total time
                // This won't affect the layout because it's inside a scrollable container
                ganttChartDiv.style.width = `${Math.max(totalTime * pixelsPerTimeUnit + 50, 800)}px`;
                
                // Create time markers and grid lines first (0 to totalTime)
                for (let t = 0; t <= totalTime; t++) {
                    // Create time marker
                    const marker = document.createElement('div');
                    marker.className = 'time-marker';
                    marker.style.left = `${t * pixelsPerTimeUnit}px`;
                    marker.textContent = t;
                    
                    // Create vertical grid line
                    const line = document.createElement('div');
                    line.className = 'time-marker-line';
                    line.style.left = `${t * pixelsPerTimeUnit}px`;
                    
                    ganttChartDiv.appendChild(marker);
                    ganttChartDiv.appendChild(line);
                }
                
                // Track processes for the legend
                const processColors = new Map();
                
                // Now add the gantt blocks with proper spacing
                this.ganttChart.forEach(block => {
                    const duration = block.endTime - block.startTime;
                    const width = duration * pixelsPerTimeUnit - 6; // Subtract margin for spacing
                    const left = block.startTime * pixelsPerTimeUnit + 3; // Add margin for spacing
                    
                    const ganttBlock = document.createElement('div');
                    ganttBlock.className = 'gantt-block';
                    ganttBlock.style.width = `${width}px`;
                    ganttBlock.style.backgroundColor = block.color;
                    ganttBlock.style.position = 'absolute';
                    ganttBlock.style.left = `${left}px`;
                    ganttBlock.style.top = '0';
                    
                    // For MLFQ, show queue level
                    let queueInfo = '';
                    if (this.currentAlgorithm === 'mlfq' && block.queueLevel !== undefined && block.processId !== "Idle") {
                        queueInfo = `<span class="gantt-block-queue">Q${block.queueLevel}</span>`;
                    }
                    
                    // Improved layout with horizontal arrangement
                    ganttBlock.innerHTML = `
                        <div class="gantt-block-content">
                            <span class="gantt-block-pid">${block.processId}</span>
                            <span class="gantt-block-time">${block.startTime}-${block.endTime}</span>
                            ${queueInfo}
                        </div>
                    `;
                    
                    ganttChartDiv.appendChild(ganttBlock);
                    
                    // Track process colors for legend
                    if (block.processId !== "Idle") {
                        processColors.set(block.processId, block.color);
                    }
                });
                
                // Add legend for processes
                if (processColors.size > 0) {
                    // Add Idle to legend first
                    const idleLegend = document.createElement('div');
                    idleLegend.className = 'legend-item';
                    idleLegend.innerHTML = `
                        <div class="legend-color" style="background-color: #555555;"></div>
                        <div>Idle</div>
                    `;
                    legendDiv.appendChild(idleLegend);
                    
                    // Sort processes by ID for consistent legend order
                    const sortedProcesses = Array.from(processColors.keys()).sort((a, b) => {
                        if (a === "Idle") return -1;
                        if (b === "Idle") return 1;
                        return a.localeCompare(b);
                    });
                    
                    sortedProcesses.forEach(processId => {
                        if (processId === "Idle") return; // Already added
                        
                        const color = processColors.get(processId);
                        const legendItem = document.createElement('div');
                        legendItem.className = 'legend-item';
                        legendItem.innerHTML = `
                            <div class="legend-color" style="background-color: ${color};"></div>
                            <div>${processId}</div>
                        `;
                        legendDiv.appendChild(legendItem);
                    });
                }
            }
            
            updateResultsTable(processes) {
                const resultsTableBody = document.getElementById('resultsTableBody');
                resultsTableBody.innerHTML = '';
                
                // Sort processes by ID for display
                const sortedProcesses = [...processes].sort((a, b) => {
                    const idA = parseInt(a.id.replace('P', ''));
                    const idB = parseInt(b.id.replace('P', ''));
                    return idA - idB;
                });
                
                sortedProcesses.forEach(process => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${process.id}</td>
                        <td>${process.arrivalTime}</td>
                        <td>${process.burstTime}</td>
                        <td>${process.waitingTime}</td>
                        <td>${process.turnaroundTime}</td>
                        <td>${process.finishTime}</td>
                    `;
                    resultsTableBody.appendChild(row);
                });
            }
            
            calculateMetrics(processes) {
                let totalWaitingTime = 0;
                let totalTurnaroundTime = 0;
                let totalResponseTime = 0;
                
                processes.forEach(process => {
                    // Calculate waiting time
                    process.waitingTime = process.finishTime - process.arrivalTime - process.burstTime;
                    
                    // Calculate turnaround time
                    process.turnaroundTime = process.finishTime - process.arrivalTime;
                    
                    totalWaitingTime += process.waitingTime;
                    totalTurnaroundTime += process.turnaroundTime;
                    totalResponseTime += process.responseTime;
                });
                
                const avgWaitingTime = totalWaitingTime / processes.length;
                const avgTurnaroundTime = totalTurnaroundTime / processes.length;
                const avgResponseTime = totalResponseTime / processes.length;
                
                document.getElementById('avgWaitingTime').textContent = avgWaitingTime.toFixed(2);
                document.getElementById('avgTurnaroundTime').textContent = avgTurnaroundTime.toFixed(2);
                document.getElementById('avgResponseTime').textContent = avgResponseTime.toFixed(2);
            }
        }

        // Initialize the scheduler
        const scheduler = new Scheduler();

        // Add sample processes
        scheduler.addProcess(new Process('P1', 0, 5));
        scheduler.addProcess(new Process('P2', 1, 3));
        scheduler.addProcess(new Process('P3', 2, 8));
        scheduler.addProcess(new Process('P4', 3, 2));
        scheduler.addProcess(new Process('P5', 4, 9));

        // Set up event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize the process ID field
            scheduler.updateNextProcessIdInput();
            
            // Initialize algorithm settings visibility
            scheduler.showAlgorithmSettings();
        });

        // Fix the duplication issue by removing the duplicate event listeners
        // and only adding them once
        const addProcessBtn = document.getElementById('addProcess');
        const clearProcessesBtn = document.getElementById('clearProcesses');
        const runSimulationBtn = document.getElementById('runSimulation');
        const generateRandomBtn = document.getElementById('generateRandom');
        const refreshPidBtn = document.getElementById('refreshPid');
        const algorithmSelect = document.getElementById('algorithmSelect');

        // Remove any existing event listeners (if any)
        addProcessBtn.replaceWith(addProcessBtn.cloneNode(true));
        clearProcessesBtn.replaceWith(clearProcessesBtn.cloneNode(true));
        runSimulationBtn.replaceWith(runSimulationBtn.cloneNode(true));
        generateRandomBtn.replaceWith(generateRandomBtn.cloneNode(true));
        refreshPidBtn.replaceWith(refreshPidBtn.cloneNode(true));
        algorithmSelect.replaceWith(algorithmSelect.cloneNode(true));

        // Re-get the elements after replacing them
        document.getElementById('addProcess').addEventListener('click', () => {
            const id = scheduler.getNextProcessId();
            const arrivalTime = document.getElementById('arrivalTime').value;
            const burstTime = document.getElementById('burstTime').value;
            
            if (!arrivalTime || !burstTime) {
                alert('Please fill in all fields!');
                return;
            }
            
            scheduler.addProcess(new Process(id, arrivalTime, burstTime));
            
            // Clear input fields except for process ID which is auto-generated
            document.getElementById('arrivalTime').value = '0';
            document.getElementById('burstTime').value = '5';
        });

        document.getElementById('clearProcesses').addEventListener('click', () => {
            scheduler.clearProcesses();
        });

        document.getElementById('runSimulation').addEventListener('click', () => {
            // Update time quantum settings before running
            if (scheduler.currentAlgorithm === 'rr') {
                scheduler.setTimeQuantum(document.getElementById('timeQuantum').value);
            } else if (scheduler.currentAlgorithm === 'mlfq') {
                scheduler.setMLFQQuantums(
                    document.getElementById('mlfq-q0').value,
                    document.getElementById('mlfq-q1').value,
                    document.getElementById('mlfq-q2').value,
                    document.getElementById('mlfq-q3').value
                );
            }
            
            scheduler.runSimulation();
        });

        document.getElementById('generateRandom').addEventListener('click', () => {
            const count = parseInt(document.getElementById('randomCount').value);
            if (isNaN(count) || count <= 0 || count > 20) {
                alert('Please enter a valid number between 1 and 20!');
                return;
            }
            scheduler.generateRandomProcesses(count);
        });

        document.getElementById('refreshPid').addEventListener('click', () => {
            scheduler.updateNextProcessIdInput();
        });

        // Algorithm selection dropdown
        document.getElementById('algorithmSelect').addEventListener('change', (e) => {
            const algorithm = e.target.value;
            scheduler.setAlgorithm(algorithm);
        });

        // Initialize the process ID field and algorithm settings
        scheduler.updateNextProcessIdInput();
        scheduler.showAlgorithmSettings();
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'96725dc8245ae39e',t:'MTc1Mzg1MjQwMy4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>